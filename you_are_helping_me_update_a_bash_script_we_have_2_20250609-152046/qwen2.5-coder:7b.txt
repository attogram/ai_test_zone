Certainly! Below is a bash script that reads and parses the `stats.txt` and `show.txt` files as described. It extracts the data into bash variables.

```bash
#!/bin/bash

# Function to parse stats.txt
parse_stats() {
    local file_path=$1
    declare -A stats_vars

    while IFS=':' read -r key value; do
        if [[ $key =~ ^\s*(.*)\s*$ ]]; then
            clean_key=${BASH_REMATCH[1]}
            if [[ $value =~ ^\s*([0-9\.]+)(.*)\s*$ ]]; then
                stats_vars[$clean_key]="${BASH_REMATCH[1]}${BASH_REMATCH[2]}"
            else
                stats_vars[$clean_key]="$value"
            fi
        fi
    done < "$file_path"

    for key in "${!stats_vars[@]}"; do
        echo "STAT: $key=${stats_vars[$key]}"
    done

    # Assign values to variables
    total_duration=${stats_vars["total duration"]}
    load_duration=${stats_vars["load duration"]}
    prompt_eval_count=${stats_vars["prompt eval count"]}
    prompt_eval_duration=${stats_vars["prompt eval duration"]}
    prompt_eval_rate=${stats_vars["prompt eval rate"]}
    eval_count=${stats_vars["eval count"]}
    eval_duration=${stats_vars["eval duration"]}
    eval_rate=${stats_vars["eval rate"]}

    echo "Total Duration: $total_duration"
    echo "Load Duration: $load_duration"
    echo "Prompt Eval Count: $prompt_eval_count"
    echo "Prompt Eval Duration: $prompt_eval_duration"
    echo "Prompt Eval Rate: $prompt_eval_rate"
    echo "Eval Count: $eval_count"
    echo "Eval Duration: $eval_duration"
    echo "Eval Rate: $eval_rate"
}

# Function to parse show.txt
parse_show() {
    local file_path=$1
    declare -A model_vars
    declare -a capabilities_vars
    declare -A parameters_vars

    section=""
    while IFS= read -r line; do
        if [[ "$line" == "Model" ]]; then
            section="model"
        elif [[ "$line" == "Capabilities" ]]; then
            section="capabilities"
        elif [[ "$line" == "Parameters" ]]; then
            section="parameters"
        else
            case $section in
                model)
                    if [[ $line =~ ^\s*(.*)\s*:\s*(.*)\s*$ ]]; then
                        key=${BASH_REMATCH[1]}
                        value=${BASH_REMATCH[2]}
                        model_vars[$key]="$value"
                    fi
                    ;;
                capabilities)
                    capability=$(echo "$line" | xargs)
                    capabilities_vars+=("$capability")
                    ;;
                parameters)
                    if [[ $line =~ ^\s*(.*)\s*:\s*(.*)\s*$ ]]; then
                        key=${BASH_REMATCH[1]}
                        value=${BASH_REMATCH[2]}
                        parameters_vars[$key]="$value"
                    fi
                    ;;
            esac
        fi
    done < "$file_path"

    for key in "${!model_vars[@]}"; do
        echo "MODEL: $key=${model_vars[$key]}"
    done

    for capability in "${capabilities_vars[@]}"; do
        echo "CAPABILITY: $capability"
    done

    for key in "${!parameters_vars[@]}"; do
        echo "PARAMETERS: $key=${parameters_vars[$key]}"
    done

    # Assign values to variables
    architecture=${model_vars["architecture"]}
    parameters=${model_vars["parameters"]}
    context_length=${model_vars["context length"]}
    embedding_length=${model_vars["embedding length"]}
    quantization=${model_vars["quantization"]}

    completion_capability=$(echo "${capabilities_vars[@]}" | grep -o "completion" || true)

    stop_value=${parameters_vars["stop"]}

    echo "Architecture: $architecture"
    echo "Parameters: $parameters"
    echo "Context Length: $context_length"
    echo "Embedding Length: $embedding_length"
    echo "Quantization: $quantization"
    echo "Completion Capability: $completion_capability"
    echo "Stop Value: $stop_value"
}

# Parse files
parse_stats stats.txt
echo
parse_show show.txt
```

### Explanation:
1. **parse_stats Function**: This function reads `stats.txt`, splits each line into a key-value pair, and stores them in an associative array. It then prints out the key-value pairs and assigns the values to corresponding bash variables.

2. **parse_show Function**: This function reads `show.txt`, handles different sections (`Model`, `Capabilities`, `Parameters`), and stores the data in associative arrays or arrays. It then prints out the key-value pairs and assigns the values to corresponding bash variables.

3. **Usage**: The script calls these functions with the respective file paths (`stats.txt` and `show.txt`). You can run this script directly from your terminal if both files are in the same directory as the script, or adjust the file paths accordingly.

This script should handle the parsing and extraction of data from both files effectively.

